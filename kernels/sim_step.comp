#version 450
layout (local_size_x = 32) in;

#include "droplet.glsl"

layout (binding = 0) uniform Settings {
    // Inertia
    float inertia;
    // Minimum slope for capacity calculation
    float min_slope;
    // Capacity for droplets to carry material
    float capacity_const;
    // Sediment dropped beyond capacity
    float deposition;
    // Sediment picked up under capacity
    float erosion;
    // Force of gravity
    float gravity;
    // Evaporation rate
    float evaporation;
};

layout (binding = 1) buffer Droplets {
    Droplet droplets[];
};

layout (binding = 2, r32f) uniform image2D heightmap;
layout (binding = 3, r32f) uniform image2D erosionmap;

vec2 gradient(vec2 pos) {
    ivec2 int_pos = ivec2(pos);
    vec2 uv = fract(pos);
    float tl = imageLoad(heightmap, int_pos + ivec2(0, 0)).r;
    float tr = imageLoad(heightmap, int_pos + ivec2(1, 0)).r;
    float bl = imageLoad(heightmap, int_pos + ivec2(0, 1)).r;
    float br = imageLoad(heightmap, int_pos + ivec2(1, 1)).r;
    return vec2(
        mix(tr - tl, br - bl, uv.y),
        mix(bl - tl, br - tr, uv.x)
    );
}

void main() {
    uint gid = gl_GlobalInvocationID.x;

    vec2 old_img_pos = droplets[gid].pos * imageSize(heightmap);

    vec2 grad = gradient(old_img_pos);
    if (length(grad) < 0.001) return;
    grad = -normalize(grad);

    vec2 dir = mix(grad, droplets[gid].dir, 0.1);
    droplets[gid].pos += dir / 1000.;
    imageStore(erosionmap, ivec2(old_img_pos), vec4(-0.0005));
    //imageAtomicExchange(erosionmap, imgpos, -0.0001);
}
